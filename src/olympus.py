# -*- generated by 1.0.11 -*-
import da
PatternExpr_692 = da.pat.TuplePattern([da.pat.ConstantPattern('inithist_response'), da.pat.FreePattern('replica')])
PatternExpr_699 = da.pat.FreePattern('p')
PatternExpr_744 = da.pat.TuplePattern([da.pat.ConstantPattern('done'), da.pat.BoundPattern('_BoundPattern747_'), da.pat.FreePattern(None)])
PatternExpr_783 = da.pat.TuplePattern([da.pat.ConstantPattern('donereplica'), da.pat.BoundPattern('_BoundPattern786_')])
PatternExpr_832 = da.pat.TuplePattern([da.pat.ConstantPattern('reconfiguration_request'), da.pat.FreePattern('signedReq'), da.pat.FreePattern('index'), da.pat.FreePattern('type')])
PatternExpr_842 = da.pat.FreePattern('p')
PatternExpr_1656 = da.pat.TuplePattern([da.pat.ConstantPattern('caught_up'), da.pat.FreePattern('caughtUp'), da.pat.FreePattern('signedResultStDict'), da.pat.FreePattern('index'), da.pat.FreePattern('type')])
PatternExpr_1668 = da.pat.FreePattern('p')
PatternExpr_1742 = da.pat.TuplePattern([da.pat.ConstantPattern('running_state'), da.pat.FreePattern('runningState'), da.pat.FreePattern('index'), da.pat.FreePattern('type')])
PatternExpr_1752 = da.pat.FreePattern('p')
PatternExpr_1789 = da.pat.TuplePattern([da.pat.ConstantPattern('wedged'), da.pat.FreePattern('wedgeSt'), da.pat.FreePattern('index'), da.pat.FreePattern('type')])
PatternExpr_1799 = da.pat.FreePattern('p')
PatternExpr_1861 = da.pat.TuplePattern([da.pat.ConstantPattern('result_shuttle_response'), da.pat.FreePattern('clientNumber')])
PatternExpr_1868 = da.pat.FreePattern('client')
_config_object = {'channel': {'fifo', 'reliable'}, 'clock': 'lamport'}
import sys
from enum import Enum
import nacl.encoding
import nacl.signing
from OrderProof import OrderProof
from OrderStatement import OrderStatement
from Crypto import Crypto
from State import State
from Validations import Validations
from ResultProof import ResultProof
from ResultStatement import ResultStatement
from Shuttle import Shuttle
from ReplicaHistory import ReplicaHistory
from ReconfigurationRequestObject import ReconfigurationRequestObject
from configread import configread
import pickle
import time
str_exp = ','
log_level = 20
cl = da.import_da('client')
rl = da.import_da('replica')

class Olympus(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._OlympusReceivedEvent_1 = []
        self._OlympusReceivedEvent_2 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_0', PatternExpr_692, sources=[PatternExpr_699], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_691]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_1', PatternExpr_744, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_2', PatternExpr_783, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_3', PatternExpr_832, sources=[PatternExpr_842], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_831]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_4', PatternExpr_1656, sources=[PatternExpr_1668], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_1655]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_5', PatternExpr_1742, sources=[PatternExpr_1752], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_1741]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_6', PatternExpr_1789, sources=[PatternExpr_1799], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_1788]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_7', PatternExpr_1861, sources=[PatternExpr_1868], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_1860])])

    def setup(self, nReplicas, clients, olympusPrivate, olympusPublic, clientPublic, failures, nonhead_timeout, config, **rest_1885):
        super().setup(nReplicas=nReplicas, clients=clients, olympusPrivate=olympusPrivate, olympusPublic=olympusPublic, clientPublic=clientPublic, failures=failures, nonhead_timeout=nonhead_timeout, config=config, **rest_1885)
        self._state.nReplicas = nReplicas
        self._state.clients = clients
        self._state.olympusPrivate = olympusPrivate
        self._state.olympusPublic = olympusPublic
        self._state.clientPublic = clientPublic
        self._state.failures = failures
        self._state.nonhead_timeout = nonhead_timeout
        self._state.config = config
        self._state.head = None
        self._state.tail = None
        self._state.replicas = []
        self._state.olympusPrivate = self._state.olympusPrivate
        self._state.olympusPublic = self._state.olympusPublic
        self._state.clientPublic = self._state.clientPublic
        self._state.replicaPublicKeysList = []
        self._state.replicaPrivateKeysList = []
        self._state.isConfigurationValid = False
        self._state.failure = self._state.failures
        self._state.configuration = (- 1)
        self._state.crypto = Crypto()
        self._state.listOfWedgeStatements = []
        self._state.numberOfWedgedResponses = 0
        self._state.lastCheckPointAccepted = None
        self._state.lastSlotNumberInPrevConfig = (- 1)
        self._state.t = self._state.config.failure_num
        self._state.checkpt_interval = self._state.config.checkpt_interval
        self._state.crytographicHashProcessDict = dict()
        self._state.numberOfCaughtUpResponses = 0
        self._state.receivedRunningState = dict()
        self._state.reconfigurationSuccess = False
        self._state.numberOfInitHistResp = 0
        self._state.clients = self._state.clients
        self._state.olympus_timeout = 1
        self._state.replicaClientResultStDict = dict()
        self._state.resultShuttleResponse = 0

    def run(self):
        self.output('Starting Olympus', level=log_level, sep=str_exp)
        self.createNewReplica()
        c = self.logical_clock()
        super()._label('_st_label_735', block=False)
        client = None

        def UniversalOpExpr_736():
            nonlocal client
            for client in self._state.clients:

                def ExistentialOpExpr_742(client):
                    for (_, _, (_ConstantPattern759_, _BoundPattern761_, _)) in self._OlympusReceivedEvent_1:
                        if (_ConstantPattern759_ == 'done'):
                            if (_BoundPattern761_ == client):
                                if True:
                                    return True
                    return False
                if (not ExistentialOpExpr_742(client=client)):
                    return False
            return True
        _st_label_735 = 0
        while (_st_label_735 == 0):
            _st_label_735 += 1
            if UniversalOpExpr_736():
                _st_label_735 += 1
            else:
                super()._label('_st_label_735', block=True)
                _st_label_735 -= 1
        self.output('olympus received done from all clients')
        self.output('olympus sending  done to all replicas')
        self.send('done', to=self._state.replicas)
        super()._label('_st_label_774', block=False)
        replica = None

        def UniversalOpExpr_775():
            nonlocal replica
            for replica in self._state.replicas:

                def ExistentialOpExpr_781(replica):
                    for (_, _, (_ConstantPattern797_, _BoundPattern799_)) in self._OlympusReceivedEvent_2:
                        if (_ConstantPattern797_ == 'donereplica'):
                            if (_BoundPattern799_ == replica):
                                if True:
                                    return True
                    return False
                if (not ExistentialOpExpr_781(replica=replica)):
                    return False
            return True
        _st_label_774 = 0
        while (_st_label_774 == 0):
            _st_label_774 += 1
            if UniversalOpExpr_775():
                _st_label_774 += 1
            else:
                super()._label('_st_label_774', block=True)
                _st_label_774 -= 1
        self.output('olympus received  done from all replicas')
        self.send(('doneolympus',), to=self.parent())
        self.output('Olympus process is getting closed', level=log_level, sep=str_exp)

    def createNewReplica(self):
        reconfigSuccessful = False
        while (not reconfigSuccessful):
            if (not (len(self._state.replicas) == 0)):
                self.send('kill', to=self._state.replicas)
            self._state.replicas = list()
            for i in range(self._state.nReplicas):
                node = ('ReplicaNode' + str(i))
                self.output(('replica node :%s' % node))
                replica = self.new(rl.Replica, num=1, at=node)
                self._state.replicas.append(list(replica)[0])
            self._state.replicas = list(self._state.replicas)
            self._state.configuration = (self._state.configuration + 1)
            self._state.head = self._state.replicas[0]
            self._state.tail = self._state.replicas[(self._state.nReplicas - 1)]
            self._state.replicaPublicKeysList = []
            self._state.replicaPrivateKeysList = []
            for i in range(self._state.nReplicas):
                (private, public) = self._state.crypto.getSignedKey()
                self._state.replicaPrivateKeysList.append(private)
                self._state.replicaPublicKeysList.append(public)
            self.output('replica private keys')
            self.output((' %s' % (self._state.replicaPrivateKeysList,)))
            self.output('replica public keys')
            self.output((' %s' % (self._state.replicaPublicKeysList,)))
            self._setup(self._state.replicas, (self._id, State.PENDING.value, self._state.olympusPublic, self._state.clientPublic, self._state.replicaPublicKeysList, self._state.replicaPrivateKeysList, self._state.nonhead_timeout, self._state.lastSlotNumberInPrevConfig, self._state.t, self._state.checkpt_interval))
            self._start(self._state.replicas)
            c = self.logical_clock()
            self._state.numberOfInitHistResp = 0
            for i in range(self._state.nReplicas):
                failcase = []
                if ((self._state.configuration, i) in self._state.failure.keys()):
                    failcase = self._state.failure[(self._state.configuration, i)]
                self.send(('inithist', self._state.receivedRunningState, self._state.replicas, self._state.head, self._state.tail, i, c, self._state.configuration, failcase), to=self._state.replicas[i])
                self.output(('Message inithist sent to replica %i' % (i,)), level=log_level, sep=str_exp)
            super()._label('_st_label_642', block=False)
            _st_label_642 = 0
            self._timer_start()
            while (_st_label_642 == 0):
                _st_label_642 += 1
                if (self._state.numberOfInitHistResp == len(self._state.replicas)):
                    self.output(('Olympus received enough number of inithist_responses:%i.Setting configuration to valid' % (self._state.numberOfInitHistResp,)), level=log_level, sep=str_exp)
                    self._state.isConfigurationValid = True
                    self.output(('Olympus sending configuration response to clients %s' % (self._state.clients,)), level=log_level, sep=str_exp)
                    self.send(('configuration_response', self._state.replicas, self._state.head, self._state.tail, self.logical_clock(), self._state.replicaPublicKeysList, self._state.isConfigurationValid), to=self._state.clients)
                    reconfigSuccessful = True
                    _st_label_642 += 1
                elif self._timer_expired:
                    self.output('Olympus: timeout out waiting inithist responses from replica. Sending inithist again', level=log_level, sep=str_exp)
                    _st_label_642 += 1
                else:
                    super()._label('_st_label_642', block=True, timeout=3)
                    _st_label_642 -= 1
            else:
                if (_st_label_642 != 2):
                    continue
            if (_st_label_642 != 2):
                break

    def getPublicKey(self, index, type):
        if (type == 'client'):
            return self._state.clientPublic[index]
        else:
            return self._state.replicaPublicKeysList[index]

    def findLastSlot(self, wedgeSt):
        lastSlotFromCheckPoint = (- 1)
        if (not (wedgeSt.checkpoint is None)):
            lastSlotFromCheckPoint = wedgeSt.checkpoint.checkpointSlot
        histories = wedgeSt.slotOperationHist
        maxSlot = (- 1)
        for (k, v) in histories.items():
            if (k > maxSlot):
                maxSlot = k
        if (lastSlotFromCheckPoint > maxSlot):
            return lastSlotFromCheckPoint
        else:
            return maxSlot

    def sendResultShuttleToClients(self):
        self.output('olympus creating result shuttle for clients')
        sendShuttle = False
        sendShuttleNum = 0
        for i in range(len(self._state.clientPublic)):
            resultProof = ResultProof([], '', 0)
            for j in range(len(self._state.replicaPublicKeysList)):
                if (j in self._state.replicaClientResultStDict):
                    resultStDict = self._state.replicaClientResultStDict[j]
                    if (i in resultStDict):
                        sendShuttle = True
                        (result, resultSt) = resultStDict[i]
                        resultProof.operationName = resultSt.operationName
                        resultProof.operationId = resultSt.operationId
                        resultProof.addStatement(resultSt)
                        self.output(('Result statement is %s for replica:%i client:%i' % (resultSt, j, i)))
            if ((sendShuttle == True) and (len(resultProof.getlistOfResultSt()) >= (self._state.t + 1))):
                sendShuttleNum = (sendShuttleNum + 1)
                self.output(('Olympus Sending result shuttle to client %i, %s ' % (i, str(self._state.clients[i]))))
                self.send(('client_operation_response', resultProof.operationName, resultProof.operationId, result, resultProof, '', 'olympus'), to=self._state.clients[i])
                sendShuttle = False
        super()._label('_st_label_1394', block=False)
        _st_label_1394 = 0
        while (_st_label_1394 == 0):
            _st_label_1394 += 1
            if (self._state.resultShuttleResponse == sendShuttleNum):
                self._state.resultShuttleResponse = 0
                _st_label_1394 += 1
            else:
                super()._label('_st_label_1394', block=True)
                _st_label_1394 -= 1

    def findConsistentHistories(self, sortedByLongestHistory):
        start = 0
        while (start < len(sortedByLongestHistory)):
            lh = sortedByLongestHistory[start]
            remaining = sortedByLongestHistory[(start + 1):]
            numberOfConsistentHistoriesFound = 1
            self._state.lastCheckPointAccepted = lh[2].checkpoint
            self._state.lastSlotNumberInPrevConfig = self.findLastSlot(lh[2])
            res = []
            res.append((lh[1], dict()))
            i = 0
            while ((numberOfConsistentHistoriesFound < (self._state.t + 1)) and (i < len(remaining))):
                curList = remaining[i]
                if (len(curList[2].slotOperationHist) == 0):
                    numberOfConsistentHistoriesFound = (numberOfConsistentHistoriesFound + 1)
                    diff = {k: lh[2].slotOperationHist[k] for k in (set(lh[2].slotOperationHist) - set(curList[2].slotOperationHist))}
                    res.append((curList[1], diff))
                else:
                    isConsistent = True
                    for (slot, currentClientOp) in curList[2].slotOperationHist.items():
                        clientOpInLH = lh[2].slotOperationHist[slot]
                        if (not (clientOpInLH is None)):
                            if ((not (currentClientOp.operationName == clientOpInLH.operationName)) and (currentClientOp.operationId == clientOpInLH.operationId)):
                                isConsistent = False
                                break
                        else:
                            isConsistent = False
                            break
                    if isConsistent:
                        numberOfConsistentHistoriesFound = (numberOfConsistentHistoriesFound + 1)
                        diff = {k: lh[2].slotOperationHist[k] for k in (set(lh[2].slotOperationHist) - set(curList[2].slotOperationHist))}
                        res.append((curList[1], diff))
                i = (i + 1)
            if (numberOfConsistentHistoriesFound >= (self._state.t + 1)):
                return (True, res)
            else:
                start = (start + 1)
        return (False, None)

    def _Olympus_handler_691(self, replica, p):
        self._state.numberOfInitHistResp = (self._state.numberOfInitHistResp + 1)
        self.output(('Olympus received inithist_response from replica: %s,numberOfInitHistResp:%i,t:%i' % (p, self._state.numberOfInitHistResp, self._state.t)), level=log_level, sep=str_exp)
    _Olympus_handler_691._labels = None
    _Olympus_handler_691._notlabels = None

    def _Olympus_handler_831(self, signedReq, index, type, p):
        msg = self._state.crypto.isSignatureVerified(self.getPublicKey(index, type), signedReq)
        self.output(('Olympus received reconfiguration_request from:%s type:%s index:%i alreadyInProgress:%s' % (msg, type, index, (not self._state.isConfigurationValid))), level=log_level, sep=str_exp)
        if ((not (msg == None)) and self._state.isConfigurationValid):
            self.output(('Reconfiguration Request Valid from:%s index:%i' % (type, index)), level=log_level, sep=str_exp)
            self._state.isConfigurationValid = False
            self.output('Olympus sending configuration INVALID to all clients ', level=log_level, sep=str_exp)
            self.send(('getconfiguration_response', self._state.isConfigurationValid), to=self._state.clients)
            req = 'wedge'
            signedReq = self._state.crypto.sign(self._state.olympusPrivate, req)
            while 1:
                self._state.listOfWedgeStatements = []
                self._state.numberOfWedgedResponses = 0
                self.send(('wedge', signedReq), to=self._state.replicas)
                self.output('Olympus sent wedge requests to all replicas', level=log_level, sep=str_exp)
                super()._label('_st_label_927', block=False)
                _st_label_927 = 0
                while (_st_label_927 == 0):
                    _st_label_927 += 1
                    if (self._state.numberOfWedgedResponses >= (self._state.t + 1)):
                        self.output(('Olympus received the quoram :%i of  wedged responses:%s' % (self._state.numberOfWedgedResponses, ','.join((((((str(a) + ',') + str(b)) + ',') + str(c)) for (a, b, c) in self._state.listOfWedgeStatements)))), level=log_level, sep=str_exp)
                        self._state.listOfWedgeStatements.sort(key=(lambda tup: ((- 1) * tup[0])))
                        self.output('olympus computing quoram of valid histories', level=log_level, sep=str_exp)
                        start = 0
                        self._state.crytographicHashProcessDict = dict()
                        self._state.numberOfCaughtUpResponses = 0
                        self._state.receivedRunningState = None
                        self._state.reconfigurationSuccess = False
                        (isValid, quoram) = self.findConsistentHistories(self._state.listOfWedgeStatements)
                        self.output(('olympus found the  quoram:%s of valid histories' % (quoram,)), level=log_level, sep=str_exp)
                        i = 0
                        self._state.replicaClientResultStDict.clear()
                        if (not (quoram is None)):
                            while (i < len(quoram)):
                                process = quoram[i][0]
                                diff = quoram[i][1]
                                signedReq = self._state.crypto.sign(self._state.olympusPrivate, diff)
                                self.output(('olympus sending the catch_up message to replica:%s' % (process,)), level=log_level, sep=str_exp)
                                self.send(('catch_up', signedReq), to=process)
                                i = (i + 1)
                            self.output('olympus waiting for the caughtUp responses from replicas', level=log_level, sep=str_exp)
                            super()._label('_st_label_1084', block=False)
                            _st_label_1084 = 0
                            while (_st_label_1084 == 0):
                                _st_label_1084 += 1
                                if (self._state.numberOfCaughtUpResponses >= (self._state.t + 1)):
                                    self.output('olympus received quoram of caughtUp responses from replicas', level=log_level, sep=str_exp)
                                    if (len(self._state.crytographicHashProcessDict) == 1):
                                        self.output('all the caughtUp responses have single hash key', level=log_level, sep=str_exp)
                                        i = 0
                                        while (i < len(quoram)):
                                            self.output(('sending out get_running_state message to  process:%s' % (quoram[i][0],)), level=log_level, sep=str_exp)
                                            self.send('get_running_state', to=quoram[i][0])
                                            super()._label('_st_label_1131', block=False)
                                            _st_label_1131 = 0
                                            self._timer_start()
                                            while (_st_label_1131 == 0):
                                                _st_label_1131 += 1
                                                if (not (self._state.receivedRunningState is None)):
                                                    self.output(('received running_state message from process:%s' % (quoram[i][0],)), level=log_level, sep=str_exp)
                                                    key = list(self._state.crytographicHashProcessDict.keys())[0]
                                                    if (self._state.crypto.getHash(self._state.receivedRunningState) == key):
                                                        self.output('running state hashes matched. Accepting the running state', level=log_level, sep=str_exp)
                                                        self.sendResultShuttleToClients()
                                                        self._state.reconfigurationSuccess = True
                                                        break
                                                    _st_label_1131 += 1
                                                elif self._timer_expired:
                                                    i = (i + 1)
                                                    _st_label_1131 += 1
                                                else:
                                                    super()._label('_st_label_1131', block=True, timeout=self._state.olympus_timeout)
                                                    _st_label_1131 -= 1
                                            else:
                                                if (_st_label_1131 != 2):
                                                    continue
                                            if (_st_label_1131 != 2):
                                                break
                                    _st_label_1084 += 1
                                else:
                                    super()._label('_st_label_1084', block=True)
                                    _st_label_1084 -= 1
                            else:
                                if (_st_label_1084 != 2):
                                    continue
                            if (_st_label_1084 != 2):
                                break
                            if self._state.reconfigurationSuccess:
                                break
                        _st_label_927 += 1
                    else:
                        super()._label('_st_label_927', block=True)
                        _st_label_927 -= 1
                else:
                    if (_st_label_927 != 2):
                        continue
                if (_st_label_927 != 2):
                    break
            self.createNewReplica()
        elif (msg is None):
            self.output('Reconfiguration Request not signed by correct process', level=log_level, sep=str_exp)
        else:
            self.output('Reconfiguration already in progress', level=log_level, sep=str_exp)
    _Olympus_handler_831._labels = None
    _Olympus_handler_831._notlabels = None

    def _Olympus_handler_1655(self, caughtUp, signedResultStDict, index, type, p):
        msg = self._state.crypto.isSignatureVerified(self.getPublicKey(index, type), caughtUp)
        resultStDict = self._state.crypto.isSignatureVerified(self.getPublicKey(index, type), signedResultStDict)
        if (not (msg == None)):
            self.output(('Olympus received caughtUp message containing runningStateHash :%s from replica:%s' % (msg, index)), level=log_level, sep=str_exp)
            if (msg in self._state.crytographicHashProcessDict):
                self._state.crytographicHashProcessDict[msg].append(p)
            else:
                self._state.crytographicHashProcessDict[msg] = [p]
            self._state.replicaClientResultStDict[index] = resultStDict
            self._state.numberOfCaughtUpResponses = (self._state.numberOfCaughtUpResponses + 1)
        else:
            self.output('caughtUp not signed by correct replica', level=log_level, sep=str_exp)
    _Olympus_handler_1655._labels = None
    _Olympus_handler_1655._notlabels = None

    def _Olympus_handler_1741(self, runningState, index, type, p):
        msg = self._state.crypto.isSignatureVerified(self.getPublicKey(index, type), runningState)
        if (not (msg == None)):
            self.output(('Olympus received runningState:%s from replica:%s' % (msg, index)), level=log_level, sep=str_exp)
            self._state.receivedRunningState = msg
        else:
            self.output('runningState not signed by correct replica', level=log_level, sep=str_exp)
    _Olympus_handler_1741._labels = None
    _Olympus_handler_1741._notlabels = None

    def _Olympus_handler_1788(self, wedgeSt, index, type, p):
        msg = self._state.crypto.isSignatureVerified(self.getPublicKey(index, type), wedgeSt)
        if (not (msg == None)):
            self.output(('Olympus received wedgeStatement:%s from replica:%s' % (msg, index)), level=log_level, sep=str_exp)
            histLen = 0
            if (not (msg.slotOperationHist is None)):
                histLen = len(msg.slotOperationHist)
            self._state.listOfWedgeStatements.append((histLen, p, msg))
            self._state.numberOfWedgedResponses = (self._state.numberOfWedgedResponses + 1)
        else:
            self.output('WedgeStatement not signed by correct replica', level=log_level, sep=str_exp)
    _Olympus_handler_1788._labels = None
    _Olympus_handler_1788._notlabels = None

    def _Olympus_handler_1860(self, clientNumber, client):
        self.output(('Olympus received resultSuttle from Client:%i' % clientNumber), level=log_level, sep=str_exp)
        self._state.resultShuttleResponse = (self._state.resultShuttleResponse + 1)
    _Olympus_handler_1860._labels = None
    _Olympus_handler_1860._notlabels = None
