# -*- generated by 1.0.11 -*-
import da
PatternExpr_982 = da.pat.ConstantPattern('done')
PatternExpr_1036 = da.pat.TuplePattern([da.pat.ConstantPattern('inithist'), da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern('c2')])
PatternExpr_1048 = da.pat.FreePattern('olympus')
PatternExpr_1429 = da.pat.TuplePattern([da.pat.ConstantPattern('client_retransmission_request'), da.pat.FreePattern('signedRequest'), da.pat.FreePattern('clientIndex')])
PatternExpr_1438 = da.pat.FreePattern('sender')
PatternExpr_1737 = da.pat.TuplePattern([da.pat.ConstantPattern('client_operation_request'), da.pat.FreePattern('signedRequest'), da.pat.FreePattern('clientIndex')])
PatternExpr_1967 = da.pat.TuplePattern([da.pat.ConstantPattern('catch_up'), da.pat.FreePattern('signedReq')])
PatternExpr_2210 = da.pat.ConstantPattern('get_running_state')
PatternExpr_2314 = da.pat.ConstantPattern('kill')
PatternExpr_2337 = da.pat.TuplePattern([da.pat.ConstantPattern('wedge'), da.pat.FreePattern('signedReq')])
PatternExpr_2860 = da.pat.TuplePattern([da.pat.ConstantPattern('forward_shuttle'), da.pat.FreePattern('signedRequest'), da.pat.FreePattern('operationName'), da.pat.FreePattern('key'), da.pat.FreePattern('value'), da.pat.FreePattern('client'), da.pat.FreePattern('operationId'), da.pat.FreePattern('slot'), da.pat.FreePattern('shuttle'), da.pat.FreePattern('clientNumber')])
PatternExpr_2883 = da.pat.BoundPattern('_BoundPattern2884_')
PatternExpr_3127 = da.pat.TuplePattern([da.pat.ConstantPattern('backward_shuttle'), da.pat.FreePattern('operationName'), da.pat.FreePattern('key'), da.pat.FreePattern('value'), da.pat.FreePattern('client'), da.pat.FreePattern('operationId'), da.pat.FreePattern('slot'), da.pat.FreePattern('shuttle'), da.pat.FreePattern('clientNumber')])
PatternExpr_3148 = da.pat.BoundPattern('_BoundPattern3149_')
PatternExpr_3347 = da.pat.TuplePattern([da.pat.ConstantPattern('checkpoint_forward_shuttle'), da.pat.FreePattern('slot'), da.pat.FreePattern('checkpointshuttle')])
PatternExpr_3356 = da.pat.BoundPattern('_BoundPattern3357_')
PatternExpr_3563 = da.pat.TuplePattern([da.pat.ConstantPattern('checkpoint_backward_shuttle'), da.pat.FreePattern('slot'), da.pat.FreePattern('checkpointshuttle')])
PatternExpr_3572 = da.pat.BoundPattern('_BoundPattern3573_')
PatternExpr_3761 = da.pat.TuplePattern([da.pat.ConstantPattern('inithist'), da.pat.FreePattern('running_State'), da.pat.FreePattern('replicas'), da.pat.FreePattern('head'), da.pat.FreePattern('tail'), da.pat.FreePattern('index'), da.pat.FreePattern('c'), da.pat.FreePattern('configuration'), da.pat.FreePattern('failcase')])
PatternExpr_3778 = da.pat.BoundPattern('_BoundPattern3779_')
_config_object = {'channel': {'fifo', 'reliable'}, 'clock': 'lamport'}
import re
import sys
import logging
import os
import time
from ensurepip import _disable_pip_configuration_settings
from lib2to3.pgen2.token import GREATEREQUAL
from enum import Enum
import nacl.encoding
import nacl.signing
from OrderProof import OrderProof
from OrderStatement import OrderStatement
from Crypto import Crypto
from State import State
from Validations import Validations
from ResultProof import ResultProof
from ResultStatement import ResultStatement
from Shuttle import Shuttle
from ReplicaHistory import ReplicaHistory
from MessageNumber import MessageNumber
from MessageTypes import MessageTypes
from FailureCase import FailureCase
from FailureChecks import FailureChecks
from Operation import Operation
from CheckpointStatement import CheckpointStatement
from CheckpointShuttle import CheckpointShuttle
from WedgedStatement import WedgedStatement
from ReconfigurationRequestObject import ReconfigurationRequestObject
import pickle
import copy
str_exp = ','
log_level = 20
ol = da.import_da('olympus')

class Replica(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._ReplicaReceivedEvent_1 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_0', PatternExpr_982, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_981]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_1', PatternExpr_1036, sources=[PatternExpr_1048], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_2', PatternExpr_1429, sources=[PatternExpr_1438], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_1428]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_3', PatternExpr_1737, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_1736]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_4', PatternExpr_1967, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_1966]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_5', PatternExpr_2210, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_2209]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_6', PatternExpr_2314, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_2313]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_7', PatternExpr_2337, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_2336]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_8', PatternExpr_2860, sources=[PatternExpr_2883], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_2859]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_9', PatternExpr_3127, sources=[PatternExpr_3148], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_3126]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_10', PatternExpr_3347, sources=[PatternExpr_3356], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_3346]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_11', PatternExpr_3563, sources=[PatternExpr_3572], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_3562]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_12', PatternExpr_3761, sources=[PatternExpr_3778], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_3760])])

    def setup(self, olympus, state, olympusPublic, clientPublic, replicaPublic, replicaPrivate, nonhead_timeout, lastSlotNumberInPrevConfig, failure_num, checkpt_interval, **rest_4001):
        super().setup(olympus=olympus, state=state, olympusPublic=olympusPublic, clientPublic=clientPublic, replicaPublic=replicaPublic, replicaPrivate=replicaPrivate, nonhead_timeout=nonhead_timeout, lastSlotNumberInPrevConfig=lastSlotNumberInPrevConfig, failure_num=failure_num, checkpt_interval=checkpt_interval, **rest_4001)
        self._state.olympus = olympus
        self._state.state = state
        self._state.olympusPublic = olympusPublic
        self._state.clientPublic = clientPublic
        self._state.replicaPublic = replicaPublic
        self._state.replicaPrivate = replicaPrivate
        self._state.nonhead_timeout = nonhead_timeout
        self._state.lastSlotNumberInPrevConfig = lastSlotNumberInPrevConfig
        self._state.failure_num = failure_num
        self._state.checkpt_interval = checkpt_interval
        self._state.isHead = False
        self._state.isTail = False
        self._state.prevReplica = None
        self._state.nextReplica = None
        self._state.runningState = None
        self._state.configuration = (- 1)
        self._state.failure_num = self._state.failure_num
        self._state.head = None
        self._state.upTime = self.logical_clock()
        self._state.state = self._state.state
        self._state.replicaChain = None
        self._state.operationDict = dict()
        self._state.resultDict = dict()
        self._state.last_slot = self._state.lastSlotNumberInPrevConfig
        self._state.index = (- 1)
        self._state.olympusPublic = self._state.olympusPublic
        self._state.clientPublic = self._state.clientPublic
        self._state.replicaPublicList = self._state.replicaPublic
        self._state.replicaPrivateList = self._state.replicaPrivate
        self._state.replicaPrivate = None
        self._state.replicaPublic = None
        self._state.validations = Validations()
        self._state.replicaHistory = ReplicaHistory()
        self._state.replicaHistory.lastCheckpointSlot = self._state.lastSlotNumberInPrevConfig
        self._state.failcase = []
        self._state.messageNumber = MessageNumber()
        self._state.crypto = Crypto()
        self._state.failureChecks = FailureChecks()
        self._state.hasReceivedDone = False
        self._state.checkpt_interval = self._state.checkpt_interval
        self._state.copiedRunningState = dict()
        self._state.timeToTerminate = False

    def run(self):
        self.output('Starting Replica', level=log_level, sep=str_exp)
        super()._label('yieldInitHist', block=False)
        olympus = c2 = None

        def ExistentialOpExpr_1034():
            nonlocal olympus, c2
            for (_, (_, _, self._state.olympus), (_ConstantPattern1058_, _, _, _, _, _, c2)) in self._ReplicaReceivedEvent_1:
                if (_ConstantPattern1058_ == 'inithist'):
                    if True:
                        return True
            return False
        _st_label_1033 = 0
        while (_st_label_1033 == 0):
            _st_label_1033 += 1
            if ExistentialOpExpr_1034():
                _st_label_1033 += 1
            else:
                super()._label('yieldInitHist', block=True)
                _st_label_1033 -= 1
        super()._label('_st_label_1069', block=False)
        _st_label_1069 = 0
        while (_st_label_1069 == 0):
            _st_label_1069 += 1
            if (self._state.timeToTerminate == True):
                self.output(('Replica:%i Terminating' % (self._state.index,)), level=log_level, sep=str_exp)
                _st_label_1069 += 1
            else:
                super()._label('_st_label_1069', block=True)
                _st_label_1069 -= 1

    def actionsAtEveryReplica(self, operationName, key, value, operationId, client, slot, shuttle, clientNumber, messageType, clientRequest):
        operation = Operation(operationName, key, value)
        result = operation.performOperation(self._state.runningState)
        replicakeyPrivate = self._state.replicaPrivate
        replicakeyPublic = None
        replicakeyPrivateO = self._state.replicaPrivate
        replicakeyPublicO = None
        replicakeyPrivateR = self._state.replicaPrivate
        replicakeyPublicR = None
        self._state.resultDict[(operationId, client)] = result
        if (((slot + 1) % self._state.checkpt_interval) == 0):
            runningStateHash = self._state.crypto.getHash(self._state.runningState)
            self._state.replicaHistory.addRunningStateHash(slot, runningStateHash)
            self.output(('Checkpoint :Running State Hash:%s is created for running state:%s and stored in history at slot %i for Replica:%i' % (runningStateHash, self._state.runningState, slot, self._state.index)))
        if (self._state.failureChecks.remove_operationhistory == False):
            self._state.replicaHistory.insertOperation((operationName, operationId, client), clientRequest, result, slot)
        else:
            self._state.failureChecks.remove_operationhistory = False
        self.output(('[Replica:%i runningState:%s OperationName:%s OperationId:%i ]' % (self._state.index, self._state.runningState, operationName, operationId)), level=log_level, sep=str_exp)
        if ((self._state.failureChecks.change_operation == True) and (self._state.isTail == False)):
            operationName = 'get'
            self.output(('operation modified for forward shuttle in Replica:%i' % self._state.index), level=log_level, sep=str_exp)
            self._state.failureChecks.change_operation = False
        if (self._state.failureChecks.change_privatekey == True):
            (replicakeyPrivateR, replicakeyPublic) = self._state.crypto.getSignedKey()
            replicakeyPrivateO = replicakeyPrivateR
            self.output(('private key modified for forward shuttle in Replica:%i' % self._state.index), level=log_level, sep=str_exp)
            self._state.failureChecks.change_privatekey = False
        if (self._state.failureChecks.invalid_order_sig == True):
            (replicakeyPrivateO, replicakeyPublicO) = self._state.crypto.getSignedKey()
            self.output(('private key modified for order proof statement in forward shuttle in Replica:%i' % self._state.index), level=log_level, sep=str_exp)
            self._state.failureChecks.invalid_order_sig = False
        if (self._state.failureChecks.invalid_result_sig == True):
            (replicakeyPrivateR, replicakeyPublicR) = self._state.crypto.getSignedKey()
            self.output(('private key modified for result proof statement forward shuttle in Replica:%i' % self._state.index), level=log_level, sep=str_exp)
            self._state.failureChecks.invalid_result_sig = False
        self.output(('result of operation is %s for Replica:%i' % (result, self._state.index)))
        orderStatement = OrderStatement(slot, operationName, operationId, self._state.index)
        self.output(('Replica:%i order statement [slot,operationName,operationId,replicaId]:%s is signed,appended to order Proof' % (self._state.index, orderStatement)))
        signedSerializedOrderStatements = self._state.crypto.sign(replicakeyPrivateO, orderStatement)
        shuttle.addOrderStatement(signedSerializedOrderStatements)
        resultHash = self._state.crypto.getHash(result)
        resultStatement = ResultStatement(resultHash, operationName, operationId, self._state.index)
        self.output(('Replica:%i result statement [result_hash,operationName,operationId,replicaId]:%s is signed,appended to result Proof' % (self._state.index, resultStatement)))
        self._state.replicaHistory.setResultStForClient(clientNumber, result, resultStatement)
        signedSerializedResultStatements = self._state.crypto.sign(replicakeyPrivateR, resultStatement)
        shuttle.addResultStatement(signedSerializedResultStatements)

    def createCheckpointShuttle(self, slot):
        checkpointshuttle = CheckpointShuttle(slot, [])
        checkpointst = CheckpointStatement(slot, self._state.replicaHistory.getRunningStateHash(slot))
        self.output(('CheckpointStatement %s created at head for slot %i\n' % (str(checkpointst), slot)))
        signedSerializedCheckpointStatements = self._state.crypto.sign(self._state.replicaPrivate, checkpointst)
        checkpointshuttle.addCheckpointStatement(signedSerializedCheckpointStatements)
        self.output(('CheckpointShuttle %s created at head for slot %i\n' % (str(checkpointshuttle), slot)))
        self.send(('checkpoint_forward_shuttle', slot, checkpointshuttle), to=self._state.nextReplica)
        self.output(('Checkpoint Forward Shuttle sent from head for slot:%i\n' % slot))

    def truncateHistory(self, slot):
        history = self._state.replicaHistory.slotOperationDict
        lastslot = self._state.replicaHistory.lastCheckpointSlot
        for i in range(lastslot, (slot + 1)):
            if (i in history):
                del history[i]
        self._state.replicaHistory.slotOperationDict = history
        self.output(('Truncated History is {%s} after checkpointing at slot %i for replica:%i\n' % (','.join((((str(k) + '=') + str(v)) for (k, v) in self._state.replicaHistory.slotOperationDict.items())), slot, self._state.index)))
        self._state.replicaHistory.lastCheckpointSlot = slot

    def initiateReconfigurationRequest(self, privateKey, index, type):
        isConfigurationValid = False
        req = ReconfigurationRequestObject(self._id)
        signedReq = self._state.crypto.sign(privateKey, req)
        self.send(('reconfiguration_request', signedReq, index, type), to=self._state.olympus)

    def generateResponseFromResultShuttle(self, operationName, key, value, client, operationId, clock, clientNumber):
        (status, shuttle) = self._state.replicaHistory.getResultShuttleForOperation((operationName, operationId, client))
        response = self._state.resultDict[(operationId, client)]
        self.send(('client_operation_response', operationName, operationId, response, shuttle.getResultProof(), self.logical_clock(), self._id), to=client)
        self.output(('Replica:%i sent client_retransmitted_response to client:%s' % (self._state.index, client)))

    def awaitingForBackwardShuttle(self, operationName, key, value, client, operationId, clock, clientNumber):
        super()._label('_st_label_1141', block=False)
        _st_label_1141 = 0
        self._timer_start()
        while (_st_label_1141 == 0):
            _st_label_1141 += 1
            if self._state.replicaHistory.isResultShuttleArrivedForOperation((operationName, operationId, client)):
                self.generateResponseFromResultShuttle(operationName, key, value, client, operationId, clock, clientNumber)
                _st_label_1141 += 1
            elif self._timer_expired:
                self.output(('Replica:%i timeout out waiting for backward shuttle client:%s' % (self._state.index, client)), level=log_level, sep=str_exp)
                self.initiateReconfigurationRequest(self._state.replicaPrivate, self._state.index, 'replica')
                _st_label_1141 += 1
            else:
                super()._label('_st_label_1141', block=True, timeout=self._state.nonhead_timeout)
                _st_label_1141 -= 1

    def initialFailureChecks(self):
        if (self._state.failureChecks.crash == True):
            self.output(('crashing initiated in Replica:%i' % self._state.index), level=log_level, sep=str_exp)
            logging.shutdown()
            os._exit((- 1))
            self._state.failureChecks.crash = False
        if (self._state.failureChecks.sleep > 0):
            self.output(('sleep for %i seconds initiated in Replica:%i' % (self._state.failureChecks.sleep, self._state.index)), level=log_level, sep=str_exp)
            time.sleep(self._state.failureChecks.sleep)
            self._state.failureChecks.sleep = False
        if ((self._state.failureChecks.increment_slot == True) and (self._state.isHead == True)):
            self._state.last_slot = (self._state.last_slot + 1)
            self.output(('Next slot number modified to %i in Replica:%i' % (self._state.last_slot, self._state.index)), level=log_level, sep=str_exp)
            self._state.failureChecks.increment_slot = False
        if (self._state.failureChecks.extra_op == True):
            operation = Operation('put', 'a', 'a')
            self.output(('New Operation put(a,a) added as failure case to running state in Replica:%i' % self._state.index), level=log_level, sep=str_exp)
            result = operation.performOperation(self._state.runningState)
            self._state.failureChecks.extra_op = False

    def failureResultCheck(self, tshuttle):
        shuttle = tshuttle
        if (self._state.failureChecks.change_result == True):
            resultstmtlist = shuttle.resultProof.getlistOfResultSt()
            currentEncodedSt = resultstmtlist[self._state.index]
            currentKey = self._state.replicaPublicList[self._state.index]
            decodeSt = self._state.crypto.isSignatureVerified(currentKey, currentEncodedSt)
            decodeSt.result = 'OK'
            decodeSt.result = self._state.crypto.getHash(decodeSt.result)
            signedSerializedResultStatements = self._state.crypto.sign(self._state.replicaPrivate, decodeSt)
            resultstmtlist[self._state.index] = signedSerializedResultStatements
            shuttle.resultProof.setlistOfOrderSt(resultstmtlist)
            self.output(('Result Shuttle modified in Replica:%i' % self._state.index))
            self._state.failureChecks.change_result = False
        if (self._state.failureChecks.drop_result_stmt == True):
            resultstmtlist = shuttle.resultProof.getlistOfResultSt()
            resultstmtlist = resultstmtlist[1:]
            shuttle.resultProof.setlistOfOrderSt(resultstmtlist)
            self.output(('Result Shuttle modified in Replica:%i' % self._state.index))
            self._state.failureChecks.drop_result_stmt = False
        return shuttle

    def validateForwardShuttle(self, signedRequest, clientIndex, operationId, operationName, slot, shuttle):
        clientRequest = self._state.crypto.isSignatureVerified(self._state.clientPublic[clientIndex], signedRequest)
        if (clientRequest is None):
            self.output('Forward Shuttle validation fail: Client Signature not verified')
        if (slot in self._state.replicaHistory.slotOperationDict.keys()):
            self.output('Forward Shuttle validation fail: slot already used')
            return False
        elif (not ((self._state.last_slot + 1) == slot)):
            self.output('Forward Shuttle validation fail: slot not continuous')
            return False
        elif (len(shuttle.orderProof.getlistOfOrderSt()) < self._state.index):
            self.output('Forward Shuttle validation fail: Order Statement of previous replica missing')
            return False
        elif (len(shuttle.resultProof.getlistOfResultSt()) < self._state.index):
            self.output('Forward Shuttle validation fail: Result Statement of previous replica missing')
            return False
        else:
            orderSt = shuttle.orderProof.getlistOfOrderSt()
            for i in range(len(orderSt)):
                currentEncodedSt = orderSt[i]
                currentKey = self._state.replicaPublicList[i]
                ordstmt = self._state.crypto.isSignatureVerified(currentKey, currentEncodedSt)
                if (ordstmt is None):
                    self.output('Forward Shuttle validation fail: Some Replica Signature not verified')
                    return False
                if (not (operationId == ordstmt.operationId)):
                    self.output('Forward Shuttle validation fail: operation ID of orderproof different')
                    return False
                if (not (operationName == ordstmt.operationName)):
                    self.output('Forward Shuttle validation fail: operationName of orderproof different')
                    return False
                if (not (slot == ordstmt.slot)):
                    self.output('Forward Shuttle validation fail: slot of orderproof different')
                    return False
            return True

    def validateBackwardShuttle(self, operationId, slot, client, shuttle):
        (isResultValid, reason) = self._state.validations.validationOfResultProof(self._state.resultDict[(operationId, client)], shuttle.resultProof, self._state.replicaPublicList, self._id)
        self.output(('%s for Replica:%i' % (str(reason), self._state.index)))
        return isResultValid

    def validateCheckpointForwardShuttle(self, slot, shuttle):
        if (slot <= self._state.replicaHistory.lastCheckpointSlot):
            self.output('Checkpoint Forward Shuttle validation fail: slot already checkpointed')
            return False
        elif (len(shuttle.listOfCheckpointSt) < self._state.index):
            self.output('Checkpoint Forward Shuttle validation fail: Checkpoint Statement of previous replica missing')
            return False
        else:
            checkpointSt = shuttle.listOfCheckpointSt
            for i in range(len(checkpointSt)):
                currentEncodedSt = checkpointSt[i]
                currentKey = self._state.replicaPublicList[i]
                chkstmt = self._state.crypto.isSignatureVerified(currentKey, currentEncodedSt)
                if (chkstmt is None):
                    self.output('Checkpoint Forward Shuttle validation fail: Signature not verified')
                    return False
                if (not (slot == chkstmt.checkpointSlot)):
                    self.output('Checkpoint Forward Shuttle validation fail: slot of checkpoint shuttle different')
                    return False
            return True

    def validateCheckpointBackwardShuttle(self, slot, shuttle):
        if ((slot - self._state.replicaHistory.lastCheckpointSlot) > self._state.checkpt_interval):
            self.output('Completed Checkpoint Proof validation fail : Completed Checkpoint Proof of previous slot has not arrived')
            return False
        if (len(shuttle.listOfCheckpointSt) < len(self._state.replicaPublicList)):
            self.output('Completed Checkpoint Proof validation fail : Checkpoint Statement of some replica missing')
            return False
        checkpointSt = shuttle.listOfCheckpointSt
        for i in range(len(checkpointSt)):
            currentEncodedSt = checkpointSt[i]
            currentKey = self._state.replicaPublicList[i]
            chkstmt = self._state.crypto.isSignatureVerified(currentKey, currentEncodedSt)
            if (chkstmt is None):
                self.output('Completed Checkpoint Proof Shuttle validation fail: Signature not verified')
                return False
            if (not (slot == chkstmt.checkpointSlot)):
                self.output('Completed Checkpoint Proof Shuttle validation fail: slot of checkpoint shuttle different')
                return False
        return True

    def _Replica_handler_981(self):
        self.output(('Replica:%i received done from olympus' % (self._state.index,)), level=log_level, sep=str_exp)
        self.send(('donereplica', self._id), to=self._state.olympus)
        self.output('replica send done to olympus')
        self._state.timeToTerminate = True
        self._state.state = State.IMMUTABLE
        self.output(('replica%i time to terminate:%s,state:%s' % (self._state.index, self._state.timeToTerminate, self._state.state)), level=log_level, sep=str_exp)
        os._exit((- 1))
    _Replica_handler_981._labels = None
    _Replica_handler_981._notlabels = None

    def _Replica_handler_1428(self, signedRequest, clientIndex, sender):
        self.output(('Replica %i received retransmitted request from process:%s client:%s ' % (self._state.index, sender, clientIndex)), level=log_level, sep=str_exp)
        res = self._state.validations.shouldReplicaAcceptRequest(self._state.state)
        if res:
            clientRequest = self._state.crypto.isSignatureVerified(self._state.clientPublic[clientIndex], signedRequest)
            if (clientRequest is None):
                self.output(('Client Retransmission Request failed validation at Replica:%i : Signature not verified' % self._state.index))
            else:
                operationName = clientRequest.operationName
                key = clientRequest.key
                value = clientRequest.value
                client = clientRequest.client
                operationId = clientRequest.operationId
                clock = clientRequest.logicalClock
                clientNumber = clientRequest.clientNumber
                if (sender in self._state.replicaChain):
                    messagetype = MessageTypes.FORWARDED
                else:
                    messagetype = MessageTypes.DIRECT
                self._state.messageNumber.incrementMessageType(clientNumber, messagetype)
                self.output(('Replica:%i {client:{message_type>messagecount}:%s' % (self._state.index, self._state.messageNumber.getDict())))
                failurecase = FailureCase(self._state.failcase, self._state.index, clientNumber, messagetype, self._state.messageNumber, self._state.failureChecks)
                self._state.failureChecks = failurecase.failureChecks
                self.output(('Failure trigger is %s, failure checks: %s for client_retransmission_request in Replica: %i' % (failurecase, self._state.failureChecks, self._state.index)))
                if (self._state.failureChecks.drop == True):
                    self.output('Dropping received message due to failure scenario')
                    self._state.failureChecks.drop = False
                else:
                    self.initialFailureChecks()
                    if self._state.replicaHistory.isResultShuttleArrivedForOperation((operationName, operationId, client)):
                        self.output(('Replica:%i has result shuttle ' % self._state.index))
                        self.generateResponseFromResultShuttle(operationName, key, value, client, operationId, clock, clientNumber)
                    elif self._state.isHead:
                        self.output(('Replica:%i doesnot have result shuttle' % self._state.index))
                        if self._state.replicaHistory.isOperationExist((operationName, operationId, client)):
                            self.output(('Replica:%i has already seen the operation' % self._state.index))
                            self.awaitingForBackwardShuttle(operationName, key, value, client, operationId, clock, clientNumber)
                        else:
                            self.output(('Replica:%i has not already seen the operation:%s.Initiating the protocol from scratch' % (self._state.index, operationName)))
                            self._state.last_slot = (self._state.last_slot + 1)
                            orderProof = OrderProof([], self._state.last_slot, operationName, operationId)
                            resultProof = ResultProof([], operationName, operationId)
                            shuttle = Shuttle(resultProof, orderProof)
                            self.actionsAtEveryReplica(operationName, key, value, operationId, client, self._state.last_slot, shuttle, clientNumber, messagetype, clientRequest)
                            self.send(('forward_shuttle', signedRequest, operationName, key, value, client, operationId, self._state.last_slot, shuttle, clientNumber), to=self._state.nextReplica)
                            self.output(('Forward Shuttle sent from head for Client:%i' % clientNumber))
                            self.awaitingForBackwardShuttle(operationName, key, value, client, operationId, clock, clientNumber)
                    else:
                        self.output(('Replica:%i is not head. Sending the retransmitted request to head:%s' % (self._state.index, self._state.head)))
                        self.send(('client_retransmission_request', operationName, key, value, client, operationId, clock, clientNumber), to=self._state.head)
                        self.awaitingForBackwardShuttle(operationName, key, value, client, operationId, clock, clientNumber)
    _Replica_handler_1428._labels = None
    _Replica_handler_1428._notlabels = None

    def _Replica_handler_1736(self, signedRequest, clientIndex):
        if self._state.validations.shouldReplicaAcceptRequest(self._state.state):
            clientRequest = self._state.crypto.isSignatureVerified(self._state.clientPublic[clientIndex], signedRequest)
            if (clientRequest is None):
                self.output(('Client Request failed validation at Replica:%i : Signature not verified' % self._state.index))
            else:
                operationName = clientRequest.operationName
                key = clientRequest.key
                value = clientRequest.value
                client = clientRequest.client
                operationId = clientRequest.operationId
                logical_Clock = clientRequest.logicalClock
                clientNumber = clientRequest.clientNumber
                messagetype = MessageTypes.DIRECT
                self._state.messageNumber.incrementMessageType(clientNumber, MessageTypes.DIRECT)
                self.output(('Replica:%i received client_operation_request:%s from client:%i ' % (self._state.index, str(self._state.messageNumber.getClientMessageTypeCount(clientNumber, messagetype)), clientNumber)), level=log_level, sep=str_exp)
                self.output(('Replica:%i {client:{message_type>messagecount} is :%s' % (self._state.index, self._state.messageNumber.getDict())))
                failurecase = FailureCase(self._state.failcase, self._state.index, clientNumber, messagetype, self._state.messageNumber, self._state.failureChecks)
                self._state.failureChecks = failurecase.failureChecks
                self.output(('Failure trigger is %s , failure checks: %s for the client_operation_request %s in Replica:%i' % (failurecase, self._state.failureChecks, str(self._state.messageNumber.getClientMessageTypeCount(clientNumber, messagetype)), self._state.index)))
                if (self._state.failureChecks.drop == True):
                    self.output('Dropping received message due to failure scenario')
                    self._state.failureChecks.drop = False
                else:
                    self.initialFailureChecks()
                    orderProof = None
                    resultProof = None
                    shuttle = None
                    if self._state.isHead:
                        self._state.last_slot = (self._state.last_slot + 1)
                        orderProof = OrderProof([], self._state.last_slot, operationName, operationId)
                        resultProof = ResultProof([], operationName, operationId)
                        shuttle = Shuttle(resultProof, orderProof)
                    self.actionsAtEveryReplica(operationName, key, value, operationId, client, self._state.last_slot, shuttle, clientNumber, messagetype, clientRequest)
                    self.send(('forward_shuttle', signedRequest, operationName, key, value, client, operationId, self._state.last_slot, shuttle, clientNumber), to=self._state.nextReplica)
                    self.output(('Forward Shuttle sent from head for Client:%i' % clientNumber))
        else:
            self.output(('replica:%i did not accept request' % self._state.index))
    _Replica_handler_1736._labels = None
    _Replica_handler_1736._notlabels = None

    def _Replica_handler_1966(self, signedReq):
        msg = self._state.crypto.isSignatureVerified(self._state.olympusPublic, signedReq)
        if (not (msg == None)):
            messagetype = MessageTypes.CATCH_UP
            self._state.messageNumber.incrementReplicaMessageType(messagetype)
            self.output(('Replica:%i received %s th catch_up:%s from olympus:%s' % (self._state.index, str(self._state.messageNumber.getReplicaMessageTypeCount(messagetype)), msg, type(msg))), level=log_level, sep=str_exp)
            self.output(('Replica:%i {message_type>messagecount} is %s\n, {client:{message_type>messagecount} is :%s' % (self._state.index, self._state.messageNumber.getReplicaDict(), self._state.messageNumber.getDict())))
            failurecase = FailureCase(self._state.failcase, self._state.index, (- 1), messagetype, self._state.messageNumber, self._state.failureChecks)
            self._state.failureChecks = failurecase.failureChecks
            self.output(('Failure trigger is %s , failure checks is %s for the catch_up:%s  in Replica:%i' % (failurecase, self._state.failureChecks, str(self._state.messageNumber.getReplicaMessageTypeCount(messagetype)), self._state.index)))
            if (self._state.failureChecks.drop == True):
                self.output('Dropping received message due to failure scenario')
                self._state.failureChecks.drop = False
            else:
                copiedClientResultStDict = dict()
                copiedClientResultStDict = {key: self._state.replicaHistory.clientResultStDict[key] for key in self._state.replicaHistory.clientResultStDict.keys()}
                self._state.copiedRunningState = {key: self._state.runningState[key] for key in self._state.runningState.keys()}
                for (k, v) in msg.items():
                    op = Operation(v.operationName, v.key, v.value)
                    result = op.performOperation(self._state.copiedRunningState)
                    resultHash = self._state.crypto.getHash(result)
                    resultStatement = ResultStatement(resultHash, v.operationName, v.operationId, self._state.index)
                    copiedClientResultStDict[v.clientNumber] = (result, resultStatement)
                self.output(('Result statements is %s for operations executed in catch_up message of replica:%i' % (copiedClientResultStDict, self._state.index)))
                runningStateHash = self._state.crypto.getHash(self._state.copiedRunningState)
                signedReq = self._state.crypto.sign(self._state.replicaPrivate, runningStateHash)
                signedResultStDict = self._state.crypto.sign(self._state.replicaPrivate, copiedClientResultStDict)
                self.send(('caught_up', signedReq, signedResultStDict, self._state.index, 'replica'), to=self._state.olympus)
        else:
            self.output(('Replica:%i received catch_up but signature not valid' % (self._state.index,)), level=log_level, sep=str_exp)
    _Replica_handler_1966._labels = None
    _Replica_handler_1966._notlabels = None

    def _Replica_handler_2209(self):
        messagetype = MessageTypes.GET_RUNNUNG_STATE
        self._state.messageNumber.incrementReplicaMessageType(messagetype)
        self.output(('Replica:%i received get_running_state:%s from olympus' % (self._state.index, str(self._state.messageNumber.getReplicaMessageTypeCount(messagetype)))), level=log_level, sep=str_exp)
        self.output(('Replica:%i {message_type>messagecount} is %s\n, {client:{message_type>messagecount} is :%s' % (self._state.index, self._state.messageNumber.getReplicaDict(), self._state.messageNumber.getDict())))
        failurecase = FailureCase(self._state.failcase, self._state.index, (- 1), messagetype, self._state.messageNumber, self._state.failureChecks)
        self._state.failureChecks = failurecase.failureChecks
        self.output(('Failure trigger is %s , failure checks is %s for the get_running_state:%s  in Replica:%i' % (failurecase, self._state.failureChecks, str(self._state.messageNumber.getReplicaMessageTypeCount(messagetype)), self._state.index)))
        if (self._state.failureChecks.drop == True):
            self.output('Dropping received message due to failure scenario')
            self._state.failureChecks.drop = False
        else:
            signedReq = self._state.crypto.sign(self._state.replicaPrivate, self._state.copiedRunningState)
            self.send(('running_state', signedReq, self._state.index, 'replica'), to=self._state.olympus)
    _Replica_handler_2209._labels = None
    _Replica_handler_2209._notlabels = None

    def _Replica_handler_2313(self):
        self.output(('Replica:%i received kill from olympus' % (self._state.index,)), level=log_level, sep=str_exp)
        logging.shutdown()
        os._exit((- 1))
    _Replica_handler_2313._labels = None
    _Replica_handler_2313._notlabels = None

    def _Replica_handler_2336(self, signedReq):
        msg = self._state.crypto.isSignatureVerified(self._state.olympusPublic, signedReq)
        if (not (msg == None)):
            messagetype = MessageTypes.WEDGE_REQUEST
            self._state.messageNumber.incrementReplicaMessageType(messagetype)
            self.output(('Replica:%i received wedge request:%s  from Olympus' % (self._state.index, str(self._state.messageNumber.getReplicaMessageTypeCount(messagetype)))), level=log_level, sep=str_exp)
            self.output(('Replica:%i {client:{message_type>messagecount} is :%s' % (self._state.index, self._state.messageNumber.getDict())))
            failurecase = FailureCase(self._state.failcase, self._state.index, (- 1), messagetype, self._state.messageNumber, self._state.failureChecks)
            self._state.failureChecks = failurecase.failureChecks
            self.output(('Failure trigger is %s , failure checks is %s for the wedge_request:%s  in Replica:%i' % (failurecase, self._state.failureChecks, str(self._state.messageNumber.getReplicaMessageTypeCount(messagetype)), self._state.index)))
            if (self._state.failureChecks.drop == True):
                self.output('Dropping received message due to failure scenario')
                self._state.failureChecks.drop = False
            else:
                wedgedSt = WedgedStatement(self._state.replicaHistory.lastCheckpointProof, self._state.replicaHistory.slotOperationDict)
                if (self._state.failureChecks.truncate_history == True):
                    if (len(wedgedSt) > 0):
                        del wedgedSt[(- 1)]
                    self._state.failureChecks.truncate_history = False
                    self.output(('Replica:%i modified its wedge statement due to failure scenario' % (self._state.index,)), level=log_level, sep=str_exp)
                signedReq = self._state.crypto.sign(self._state.replicaPrivate, wedgedSt)
                self._state.state = State.IMMUTABLE
                self.output(('Replica:%i changed its state  to IMMUTABLE' % (self._state.index,)), level=log_level, sep=str_exp)
                self.output(('Replica:%i sending its wedged statement:%s to olympus' % (self._state.index, wedgedSt)), level=log_level, sep=str_exp)
                self.send(('wedged', signedReq, self._state.index, 'replica'), to=self._state.olympus)
        else:
            self.output(('Replica:%i received wedge request but signature not valid' % (self._state.index,)), level=log_level, sep=str_exp)
    _Replica_handler_2336._labels = None
    _Replica_handler_2336._notlabels = None

    def _Replica_handler_2859(self, signedRequest, operationName, key, value, client, operationId, slot, shuttle, clientNumber):
        if self._state.validations.shouldReplicaAcceptRequest(self._state.state):
            messagetype = MessageTypes.SHUTTLE
            self._state.messageNumber.incrementMessageType(clientNumber, messagetype)
            self.output(('Replica:%i received forward shuttle:%s for client:%i' % (self._state.index, str(self._state.messageNumber.getClientMessageTypeCount(clientNumber, messagetype)), clientNumber)), level=log_level, sep=str_exp)
            self.output(('Replica:%i {client:{message_type>messagecount} is :%s' % (self._state.index, self._state.messageNumber.getDict())))
            failurecase = FailureCase(self._state.failcase, self._state.index, clientNumber, messagetype, self._state.messageNumber, self._state.failureChecks)
            self._state.failureChecks = failurecase.failureChecks
            self.output(('Failure trigger is %s , failure checks is %s for the forward shuttle:%s client:%i in Replica:%i' % (failurecase, self._state.failureChecks, str(self._state.messageNumber.getClientMessageTypeCount(clientNumber, messagetype)), clientNumber, self._state.index)))
            if (self._state.failureChecks.drop == True):
                self.output('Dropping received message due to failure scenario')
                self._state.failureChecks.drop = False
            else:
                self.initialFailureChecks()
                if (self.validateForwardShuttle(signedRequest, clientNumber, operationId, operationName, slot, shuttle) == False):
                    self.output(('Forward Shuttle:%s for Client:%i failed validation at Replica:%i' % (str(self._state.messageNumber.getClientMessageTypeCount(clientNumber, messagetype)), clientNumber, self._state.index)))
                    self.initiateReconfigurationRequest(self._state.replicaPrivate, self._state.index, 'replica')
                    self.output(('Replica:%i sent reconfiguration_request to Olympus' % self._state.index))
                else:
                    self.output(('Forward Shuttle:%s for Client:%i passed validation at Replica:%i' % (str(self._state.messageNumber.getClientMessageTypeCount(clientNumber, messagetype)), clientNumber, self._state.index)))
                    self._state.last_slot = slot
                    clientRequest = self._state.crypto.isSignatureVerified(self._state.clientPublic[clientNumber], signedRequest)
                    self.actionsAtEveryReplica(operationName, key, value, operationId, client, slot, shuttle, clientNumber, messagetype, clientRequest)
                    if self._state.isTail:
                        response = self._state.resultDict[(operationId, client)]
                        shuttle = self.failureResultCheck(shuttle)
                        self.send(('client_operation_response', operationName, operationId, response, shuttle.getResultProof(), self.logical_clock(), self._id), to=client)
                        self.output(('client result shuttle sent from tail to client:%i' % clientNumber))
                        self._state.replicaHistory.setResultShuttleForOperation((operationName, operationId, client), shuttle)
                        self.send(('backward_shuttle', operationName, key, value, client, operationId, slot, shuttle, clientNumber), to=self._state.prevReplica)
                        self.output('backward shuttle generated from tail')
                    else:
                        self.send(('forward_shuttle', signedRequest, operationName, key, value, client, operationId, slot, shuttle, clientNumber), to=self._state.nextReplica)
                        self.output('forward shuttle sent to next replica')
    _Replica_handler_2859._labels = None
    _Replica_handler_2859._notlabels = None

    def _Replica_handler_3126(self, operationName, key, value, client, operationId, slot, shuttle, clientNumber):
        if self._state.validations.shouldReplicaAcceptRequest(self._state.state):
            messagetype = MessageTypes.RESULT_SHUTTLE
            self._state.messageNumber.incrementMessageType(clientNumber, messagetype)
            self.output(('Replica:%i received backward shuttle:%s for client:%i' % (self._state.index, str(self._state.messageNumber.getClientMessageTypeCount(clientNumber, messagetype)), clientNumber)), level=log_level, sep=str_exp)
            self.output(('Replica:%i {client:{message_type>messagecount}:%s' % (self._state.index, self._state.messageNumber.getDict())))
            failurecase = FailureCase(self._state.failcase, self._state.index, clientNumber, messagetype, self._state.messageNumber, self._state.failureChecks)
            self._state.failureChecks = failurecase.failureChecks
            self.output(('Failure trigger is %s , failure checks is %s for the backward shuttle:%s client:%i in Replica:%i' % (failurecase, self._state.failureChecks, str(self._state.messageNumber.getClientMessageTypeCount(clientNumber, messagetype)), clientNumber, self._state.index)))
            if (self._state.failureChecks.drop == True):
                self.output('Dropping received message due to failure scenario')
                self._state.failureChecks.drop = False
            else:
                self.initialFailureChecks()
                if (self.validateBackwardShuttle(operationId, slot, client, shuttle) == False):
                    self.output(('Backward Shuttle:%s for client:%i failed validation at Replica:%i' % (str(self._state.messageNumber.getClientMessageTypeCount(clientNumber, messagetype)), clientNumber, self._state.index)))
                    self.initiateReconfigurationRequest(self._state.replicaPrivate, self._state.index, 'replica')
                    self.output(('Replica:%i sent reconfiguration_request to Olympus' % self._state.index))
                else:
                    self.output(('Backward Shuttle:%s for client:%i passed validation at Replica:%i' % (str(self._state.messageNumber.getClientMessageTypeCount(clientNumber, messagetype)), clientNumber, self._state.index)))
                    self._state.replicaHistory.setResultShuttleForOperation((operationName, operationId, client), shuttle)
                    self.output(('[Replica:%i runningState:%s OperationName:%s OperationId:%i]' % (self._state.index, self._state.runningState, operationName, operationId)), level=log_level, sep=str_exp)
                    if self._state.isHead:
                        self.output('backward shuttle reached head')
                        if (((slot + 1) % self._state.checkpt_interval) == 0):
                            self.createCheckpointShuttle(slot)
                    else:
                        shuttle = self.failureResultCheck(shuttle)
                        self.send(('backward_shuttle', operationName, key, value, client, operationId, slot, shuttle, clientNumber), to=self._state.prevReplica)
                        self.output('backward shuttle sent to previous replica')
    _Replica_handler_3126._labels = None
    _Replica_handler_3126._notlabels = None

    def _Replica_handler_3346(self, slot, checkpointshuttle):
        if self._state.validations.shouldReplicaAcceptRequest(self._state.state):
            messagetype = MessageTypes.CHECKPOINT
            self._state.messageNumber.incrementReplicaMessageType(messagetype)
            self.output(('Replica:%i received checkpoint forward shuttle:%s for slot:%i' % (self._state.index, str(self._state.messageNumber.getReplicaMessageTypeCount(messagetype)), slot)), level=log_level, sep=str_exp)
            self.output(('Replica:%i {replica:{message_type>messagecount} is :%s' % (self._state.index, self._state.messageNumber.getReplicaDict())))
            failurecase = FailureCase(self._state.failcase, self._state.index, (- 1), messagetype, self._state.messageNumber, self._state.failureChecks)
            self._state.failureChecks = failurecase.failureChecks
            self.output(('Failure trigger is %s , failure checks is %s for the checkpoint forward shuttle:%s slot:%i in Replica:%i' % (failurecase, self._state.failureChecks, str(self._state.messageNumber.getReplicaMessageTypeCount(messagetype)), slot, self._state.index)))
            if (self._state.failureChecks.drop == True):
                self.output('Dropping received message due to failure scenario')
                self._state.failureChecks.drop = False
            else:
                self.initialFailureChecks()
                if (self.validateCheckpointForwardShuttle(slot, checkpointshuttle) == False):
                    self.output(('Chcekpoint Forward Shuttle:%s for slot:%i failed validation at Replica:%i' % (str(self._state.messageNumber.getReplicaMessageTypeCount(messagetype)), slot, self._state.index)))
                    self.initiateReconfigurationRequest(self._state.replicaPrivate, self._state.index, 'replica')
                    self.output(('Replica:%i sent reconfiguration_request to Olympus' % self._state.index))
                else:
                    self.output(('Checkpoint Forward Shuttle:%s for slot:%i passed validation at Replica:%i' % (str(self._state.messageNumber.getReplicaMessageTypeCount(messagetype)), slot, self._state.index)))
                    checkpointst = CheckpointStatement(slot, self._state.replicaHistory.getRunningStateHash(slot))
                    self.output(('CheckpointStatement %s created at replica:%i for slot %i\n' % (str(checkpointst), self._state.index, slot)))
                    signedSerializedCheckpointStatements = self._state.crypto.sign(self._state.replicaPrivate, checkpointst)
                    checkpointshuttle.addCheckpointStatement(signedSerializedCheckpointStatements)
                    self.output(('CheckpointSt is appended to CheckpointShuttle %s at replica:%i for slot %i\n' % (str(checkpointshuttle), self._state.index, slot)))
                    if self._state.isTail:
                        self.truncateHistory(slot)
                        self._state.replicaHistory.lastCheckpointProof = checkpointshuttle
                        self.send(('checkpoint_backward_shuttle', slot, checkpointshuttle), to=self._state.prevReplica)
                        self.output('completed checkpoint proof shuttle generated from tail')
                    else:
                        self.send(('checkpoint_forward_shuttle', slot, checkpointshuttle), to=self._state.nextReplica)
                        self.output('forward shuttle sent to next replica')
    _Replica_handler_3346._labels = None
    _Replica_handler_3346._notlabels = None

    def _Replica_handler_3562(self, slot, checkpointshuttle):
        if self._state.validations.shouldReplicaAcceptRequest(self._state.state):
            messagetype = MessageTypes.COMPLETED_CHECKPOINT
            self._state.messageNumber.incrementReplicaMessageType(messagetype)
            self.output(('Replica:%i received completed checkpoint proof shuttle:%s for slot:%i' % (self._state.index, str(self._state.messageNumber.getReplicaMessageTypeCount(messagetype)), slot)), level=log_level, sep=str_exp)
            self.output(('Replica:%i {replica:{message_type>messagecount} is :%s' % (self._state.index, self._state.messageNumber.getReplicaDict())))
            failurecase = FailureCase(self._state.failcase, self._state.index, (- 1), messagetype, self._state.messageNumber, self._state.failureChecks)
            self._state.failureChecks = failurecase.failureChecks
            self.output(('Failure trigger is %s , failure checks is %s for the completed checkpoint proof shuttle:%s slot:%i in Replica:%i' % (failurecase, self._state.failureChecks, str(self._state.messageNumber.getReplicaMessageTypeCount(messagetype)), slot, self._state.index)))
            if (self._state.failureChecks.drop == True):
                self.output('Dropping received message due to failure scenario')
                self._state.failureChecks.drop = False
            else:
                self.initialFailureChecks()
                if (self.validateCheckpointBackwardShuttle(slot, checkpointshuttle) == False):
                    self.output(('Completed Chcekpoint Proof Shuttle:%s for slot:%i failed validation at Replica:%i' % (str(self._state.messageNumber.getReplicaMessageTypeCount(messagetype)), slot, self._state.index)))
                    self.initiateReconfigurationRequest(self._state.replicaPrivate, self._state.index, 'replica')
                    self.output(('Replica:%i sent reconfiguration_request to Olympus' % self._state.index))
                else:
                    self.output(('Completed Chcekpoint Proof Shuttle:%s for slot:%i passed validation at Replica:%i' % (str(self._state.messageNumber.getReplicaMessageTypeCount(messagetype)), slot, self._state.index)))
                    self.truncateHistory(slot)
                    self._state.replicaHistory.lastCheckpointProof = checkpointshuttle
                    if (self._state.failureChecks.drop_checkpt_stmts == True):
                        checkpointshuttle.listOfCheckpointSt = checkpointshuttle.listOfCheckpointSt[self._state.failure_num:]
                        self.output(('Replica:%i modified the completed checkpoint Proof due to failure scenario' % (self._state.index,)), level=log_level, sep=str_exp)
                        self._state.failureChecks.drop_checkpt_stmts = False
                    if self._state.isHead:
                        self.output('completed checkpoint proof shuttle reached head')
                    else:
                        self.send(('checkpoint_backward_shuttle', slot, checkpointshuttle), to=self._state.prevReplica)
                        self.output('Completed Chcekpoint Proof Shuttle sent to previous replica')
    _Replica_handler_3562._labels = None
    _Replica_handler_3562._notlabels = None

    def _Replica_handler_3760(self, running_State, replicas, head, tail, index, c, configuration, failcase):
        self._state.head = head
        self._state.runningState = running_State
        self._state.replicaChain = replicas
        self._state.index = index
        self._state.replicaPrivate = self._state.replicaPrivateList[index]
        self._state.replicaPublic = self._state.replicaPublicList[index]
        self._state.configuration = configuration
        self._state.failcase = failcase
        messagetype = MessageTypes.NEW_CONFIGURATION
        self._state.messageNumber.incrementReplicaMessageType(messagetype)
        self.output(('Replica:%i received init_hist:%s from olympus' % (index, str(self._state.messageNumber.getReplicaMessageTypeCount(messagetype)))), level=log_level, sep=str_exp)
        self.output(('Replica:%i {message_type>messagecount} is %s\n, {client:{message_type>messagecount} is :%s' % (index, self._state.messageNumber.getReplicaDict(), self._state.messageNumber.getDict())))
        failurecase = FailureCase(failcase, index, (- 1), messagetype, self._state.messageNumber, self._state.failureChecks)
        self._state.failureChecks = failurecase.failureChecks
        self.output(('Failure trigger is %s , failure checks is %s for the init_hist:%s  in Replica:%i' % (failurecase, self._state.failureChecks, str(self._state.messageNumber.getReplicaMessageTypeCount(messagetype)), index)))
        if (self._state.failureChecks.drop == True):
            self.output('Dropping received message due to failure scenario')
            self._state.failureChecks.drop = False
        else:
            self.output(('replica %i received inithist from olympus runningState:%s  slot:%i' % (index, running_State, self._state.lastSlotNumberInPrevConfig)), level=log_level, sep=str_exp)
            if (index == 0):
                self._state.isHead = True
                self._state.nextReplica = self._state.replicaChain[(index + 1)]
                self.output(('Replica %i is head' % (index,)), level=log_level, sep=str_exp)
            elif (index == (len(self._state.replicaChain) - 1)):
                self._state.isTail = True
                self._state.prevReplica = self._state.replicaChain[(index - 1)]
                self.output(('Replica %i is tail' % (index,)), level=log_level, sep=str_exp)
            else:
                self._state.prevReplica = self._state.replicaChain[(index - 1)]
                self._state.nextReplica = self._state.replicaChain[(index + 1)]
            self._state.state = State.ACTIVE
            self.send(('inithist_response', self._id), to=self._state.olympus)
    _Replica_handler_3760._labels = frozenset({'yieldInitHist'})
    _Replica_handler_3760._notlabels = None
